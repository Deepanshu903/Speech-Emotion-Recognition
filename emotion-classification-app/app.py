# -*- coding: utf-8 -*-
"""Copy of AudioProcessing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ybB1f_gPtf_owdug_P_ss3GcuoZQMJqR
"""

import streamlit as st
import numpy as np
import librosa
import tensorflow as tf
from tensorflow.keras.models import load_model
import os
import pickle # Added for potential future use or if any .pkl files are loaded

# Constants
SAMPLE_RATE = 22050
DURATION = 3
N_MELS = 128
EXPECTED_SHAPE = (128, 128)
EMOTIONS = ['neutral', 'calm', 'happy', 'sad', 'angry', 'fear', 'disgust', 'surprise']

# Load model and normalization data
@st.cache_resource
def load_artifacts():
    """
    Loads the trained Keras model, mean, and standard deviation for normalization.
    Uses st.cache_resource to cache these heavy objects for performance.
    Includes robust path handling and explicit error messages for debugging.
    """
    # Get the base directory where app.py resides to construct absolute paths
    current_dir = os.path.dirname(__file__)

    # Define paths for all necessary artifact files
    model_path = os.path.join(current_dir, 'trained_model.h5')
    mean_path = os.path.join(current_dir, 'train_mean.npy')
    std_path = os.path.join(current_dir, 'train_std.npy')

    # Display debug information in Streamlit UI to help diagnose path issues
    st.write(f"DEBUG: Current working directory: `{os.getcwd()}`")
    st.write(f"DEBUG: Script directory: `{current_dir}`")
    st.write(f"DEBUG: Attempting to load artifacts from: `{current_dir}`")

    # Explicitly check for file existence for each artifact
    # If a file is not found, display a FATAL ERROR and raise FileNotFoundError
    if not os.path.exists(model_path):
        st.error(f"FATAL ERROR: Model file not found at: `{model_path}`")
        raise FileNotFoundError(
            f"Missing `trained_model.h5` at {model_path}. "
            "Please ensure it's in your Git repository's 'emotion-classification-app' folder and correctly cased."
        )
    if not os.path.exists(mean_path):
        st.error(f"FATAL ERROR: Mean file not found at: `{mean_path}`")
        raise FileNotFoundError(
            f"Missing `train_mean.npy` at {mean_path}. "
            "Please ensure it's in your Git repository's 'emotion-classification-app' folder and correctly cased."
        )
    if not os.path.exists(std_path):
        st.error(f"FATAL ERROR: Std file not found at: `{std_path}`")
        raise FileNotFoundError(
            f"Missing `train_std.npy` at {std_path}. "
            "Please ensure it's in your Git repository's 'emotion-classification-app' folder and correctly cased."
        )

    # Attempt to load the Keras model
    try:
        st.write(f"DEBUG: Attempting to load Keras model from `{model_path}`...")
        # compile=False is used as the model is for inference and avoids needing
        # the original optimizer/loss if they are not strictly necessary for prediction.
        model = load_model(model_path, compile=False)
        st.success("Keras model loaded successfully!")
    except Exception as e:
        # Catch any exception during model loading and provide a more informative error
        st.error(
            f"ERROR: Could not load Keras model from `{model_path}`. "
            "This often means the file is corrupted or saved with an incompatible TensorFlow version. "
            f"Details: {e}"
        )
        raise e # Re-raise the exception to propagate the error and stop app execution

    # Attempt to load the numpy mean array
    try:
        st.write(f"DEBUG: Attempting to load mean array from `{mean_path}`...")
        mean = np.load(mean_path)
        st.success("Mean array loaded successfully!")
    except Exception as e:
        st.error(f"ERROR: Could not load `train_mean.npy` from `{mean_path}`. Details: {e}")
        raise e

    # Attempt to load the numpy standard deviation array
    try:
        st.write(f"DEBUG: Attempting to load std array from `{std_path}`...")
        std = np.load(std_path)
        st.success("Std array loaded successfully!")
    except Exception as e:
        st.error(f"ERROR: Could not load `train_std.npy` from `{std_path}`. Details: {e}")
        raise e

    return model, mean, std

# Call the function to load artifacts at app startup
# This will execute only once due to st.cache_resource
model, mean, std = load_artifacts()

# Function to extract log-mel spectrogram features from audio
def extract_log_mel(audio_file_path):
    """
    Extracts log-mel spectrogram from an audio file.
    Pads or truncates the audio to a fixed duration and the spectrogram to a fixed shape.
    """
    # Load audio file using librosa
    y, sr = librosa.load(audio_file_path, sr=SAMPLE_RATE, duration=DURATION)

    # Pad or truncate audio to ensure consistent length (SAMPLE_RATE * DURATION samples)
    if len(y) < SAMPLE_RATE * DURATION:
        y = np.pad(y, (0, SAMPLE_RATE * DURATION - len(y)), mode='constant')
    else:
        y = y[:SAMPLE_RATE * DURATION]

    # Compute mel spectrogram
    S = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=N_MELS)
    # Convert to decibels
    S_db = librosa.power_to_db(S, ref=np.max)

    # Pad or truncate spectrogram to ensure consistent shape (N_MELS, EXPECTED_SHAPE[1])
    if S_db.shape[1] < EXPECTED_SHAPE[1]:
        S_db = np.pad(S_db, ((0,0), (0, EXPECTED_SHAPE[1] - S_db.shape[1])), mode='constant')
    else:
        S_db = S_db[:, :EXPECTED_SHAPE[1]]

    return S_db

# Streamlit User Interface (UI)
st.title("ðŸŽ§ Speech Emotion Recognition")
st.markdown("Upload an audio file (.wav) to predict the emotion expressed.")

# File uploader widget for audio files
uploaded_file = st.file_uploader("Choose an audio file", type=["wav"])

if uploaded_file is not None:
    # Display the uploaded audio file
    st.audio(uploaded_file, format="audio/wav")

    temp_audio_path = "temp_uploaded_audio.wav" # Use a distinct temporary filename

    try:
        # Save the uploaded file temporarily to process with librosa
        with open(temp_audio_path, "wb") as f:
            f.write(uploaded_file.getbuffer())
        st.info(f"Audio file temporarily saved for processing: `{temp_audio_path}`")

        # Extract features from the temporary audio file
        mel = extract_log_mel(temp_audio_path)

        # Normalize the extracted features using pre-loaded mean and standard deviation
        mel = (mel - mean) / std

        # Reshape the features to match the model's input shape (add batch and channel dimensions)
        mel = mel[np.newaxis, ..., np.newaxis]

        st.write("DEBUG: Performing model prediction...")
        # Make a prediction using the loaded Keras model
        prediction = model.predict(mel)

        # Get the predicted class (emotion) and its confidence
        pred_class = np.argmax(prediction)
        confidence = prediction[0][pred_class]

        # Display the prediction results
        st.success(f"**Predicted Emotion:** {EMOTIONS[pred_class]}")
        st.info(f"**Confidence:** {confidence:.2f}")

    except Exception as e:
        # Catch and display any errors that occur during the audio processing or prediction
        st.error(f"An error occurred during audio processing or prediction: {e}")
        st.exception(e) # Display full exception details for deep debugging
    finally:
        # Ensure the temporary audio file is removed after processing, regardless of success or failure
        if os.path.exists(temp_audio_path):
            os.remove(temp_audio_path)
            st.write(f"DEBUG: Cleaned up temporary audio file: `{temp_audio_path}`")